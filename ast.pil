import "object.pil"
import "builtin/list.pil"

import diesler
import diesler::util

String diesler::util::spaces(Int n) {
  var m = new MutableString();
  for(Int i = 0; i < n; i++) {
    m.append("  ");
  }
  return m.as<String>;
}

class diesler::ASTNode extends DSLObject {
  new(DSLObject instanceOf) extends super(instanceOf.as<DSLClass>) {
  }

  String toIndentedString(Int depth) {
    return this.as<String>;
  }
}

class diesler::ASTMessageSend extends diesler::ASTNode {
  ASTNode object = null;
  String selector = null;
  Array<ASTNode> arguments = null;

  new(Scope scope, ASTNode object, String selector, Array<ASTNode> arguments) extends super(scope["ASTMessageSend"]) {
    this.object = object;
    this.selector = selector;
    this.arguments = arguments;
  }

  String toIndentedString(Int depth) {
    var s = new MutableString();
    s.append(spaces(depth));
    s.append("(");
    if(object != null) {
      s.append(object.as<String>);
      s.append(" ");
    }
    s.append(selector);
    var sawCons = false;
    for(ASTNode t: arguments) {
      if(t instanceof ASTMessageSend) {
        s.append("\n");
        sawCons = true;
      } else {
        s.append(' ');
      }
      s.append(t.toIndentedString(depth+1));
    }
    s.append(')');
    return s.as<String>;
  }

  as<String> {
    return toIndentedString(0);
  }
}

class diesler::ASTBlock extends diesler::ASTNode {
  Array<ASTNode> statements = null;

  new(Scope scope, Array<ASTNode> statements) extends super(scope["ASTBlock"]) {
    this.statements = statements;
  }

  String toIndentedString(Int depth) {
    var s = new MutableString();
    s.append("[\n");
    for(ASTNode t : statements) {
      s.append(t.toIndentedString(depth+1));
      s.append('\n');
    }
    s.append(spaces(depth));
    s.append("]");
    return s.as<String>;
  }

  as<String> {
    return toIndentedString(0);
  }
}

class diesler::ASTPatternCase extends diesler::ASTNode {
  ASTMatch match = null;
  ASTBlock block = null;

  new(Scope scope, ASTMatch match, ASTBlock block) extends super(scope["ASTPatternCase"]) {
    this.match = match;
    this.block = block;
  }

  String toIndentedString(Int depth) {
    return "A pattern case";
  }
}

class diesler::ASTMethodDef extends diesler::ASTNode {
  ASTMethodSignature signature = null;
  Array<ASTNode> statements = null;

  new(Scope scope, ASTMethodSignature signature, Array<ASTNode> statements) extends super(scope["ASTMethodDef"]) {
    this.signature = signature;
    this.statements = statements;
  }

  String toIndentedString(Int depth) {
    var s = new MutableString();
    s.append(signature.as<String>);
    s.append(" [\n");
    for(ASTNode t : statements) {
      s.append(t.toIndentedString(depth+1));
      s.append('\n');
    }
    s.append(spaces(depth));
    s.append("]");
    return s.as<String>;
  }

  as<String> {
    return toIndentedString(0);
  }
}

class diesler::ASTMethodSignature extends diesler::ASTNode {
  String selector = null;
  Array<ASTMatch> arguments = null;

  new(Scope scope, String selector, Array<ASTMatch> arguments) extends super(scope["ASTMethodSignature"]) {
    this.selector = selector;
    this.arguments = arguments;
  }
}

class diesler::ASTAssign extends diesler::ASTNode {
  ASTMatch lhs = null;
  ASTNode value = null;

  new(Scope scope, ASTMatch lhs, ASTNode value) extends super(scope["ASTAssignment"]) {
    this.lhs = lhs;
    this.value = value;
  }

  String toIndentedString(Int depth) {
    var s = new MutableString();
    s.append("(=\n");
    s.append(spaces(depth) + lhs.toIndentedString(depth+1) + "\n");
    s.append(spaces(depth) + value.toIndentedString(depth+1));
    s.append(")");
    return s.as<String>;
  }
}

class diesler::ASTList extends diesler::ASTNode {
  Array<ASTNode> values = null;

  new(Scope scope, Array<ASTNode> values) extends super(scope["ASTList"]) {
    this.values = values;
  }

  String toIndentedString(Int depth) {
    var s = new MutableString();
    for(ASTNode value : values) {
      s.append(value.as<String>);
      if(value != values[values.length-1]) {
        s.append(", ");
      }
    }
    return s.as<String>;
  }
}

class diesler::ASTInt extends diesler::ASTNode {
  Int value = 0;

  new(Scope scope, Int value) extends super(scope["ASTInt"]) {
    this.value = value;
  }

  Bool ==(Object o) {
    if(o == null) {
      return false;
    }
    if(o instanceof ASTInt) {
      return o.as<ASTInt>.value == value;
    } else {
      return false;
    }
  }

  as<String> {
    var ms = new MutableString();
    ms.append(value);
    return ms.as<String>;
  }
}

class diesler::ASTBool extends diesler::ASTNode {
  Bool value = false;

  new(Scope scope, Bool value) extends super(scope["ASTBool"]) {
    this.value = value;
  }

  as<String> {
    var ms = new MutableString();
    ms.append(value);
    return ms.as<String>;
  }
}

class diesler::ASTString extends diesler::ASTNode {
  String value = null;

  new(Scope scope, String value) extends super(scope["ASTString"]) {
    this.value = value;
  }

  Bool ==(Object o) {
    if(o == null) {
      return false;
    }
    if(o instanceof ASTString) {
      return o.as<ASTString>.value == value;
    } else {
      return false;
    }
  }

  as<String> {
    return "\"" + value + "\"";
  }
}

class diesler::ASTIdn extends diesler::ASTNode {
  String idn = null;

  new(Scope scope, String idn) extends super(scope["ASTIdentifier"]) {
    this.idn = idn;
  }

  as<String> {
    return idn;
  }
}

class diesler::ASTFieldName extends diesler::ASTNode {
  String fieldName = null;

  new(Scope scope, String fieldName) extends super(scope["ASTFieldName"]) {
    this.fieldName = fieldName;
  }

  as<String> {
    return fieldName;
  }
}

class diesler::ASTMatch extends diesler::ASTNode {
  ASTNode condition = null;

  new(DSLObject cls) extends super(cls) {
  }

  Bool match(Scope scope, DSLObject other) {
    return false;
  }
}

Bool diesler::checkMatch(Scope scope, ASTNode condition, DSLObject object) {
  if(condition == null) {
    return true;
  }
  DSLObject result = scope.createLightSubScope(object).evalExp(condition);
  if(result instanceof DSLBool) {
    return result.as<DSLBool>.value;
  } else {
    return false;
  }
}

class diesler::ASTIdnMatch extends diesler::ASTMatch {
  String idn = null;

  new(Scope scope, String idn) extends super(scope["ASTIdentifierMatch"]) {
    this.idn = idn;
  }

  Bool match(Scope scope, DSLObject other) {
    scope[idn] = other;
    return checkMatch(scope, condition, other);
  }

  as<String> {
    return idn;
  }
}

class diesler::ASTFieldNameMatch extends diesler::ASTMatch {
  String fieldName = null;

  new(Scope scope, String fieldName) extends super(scope["ASTIdentifierMatch"]) {
    this.fieldName = fieldName;
  }

  Bool match(Scope scope, DSLObject other) {
    if(checkMatch(scope, condition, other)) {
      scope.self.setField(fieldName, other);
      return true;
    } else {
      return false;
    }
  }

  as<String> {
    return fieldName;
  }
}

class diesler::ASTListMatch extends diesler::ASTMatch {
  Array<ASTMatch> items = null;

  new(Scope scope, Array<ASTMatch> items) extends super(scope["ASTListMatch"]) {
    this.items = items;
  }

  Bool match(Scope scope, DSLObject other) {
    if(!(other instanceof DSLList)) {
      return false;
    }
    var l = other.as<DSLList>;
    if(l.items.length != items.length) {
      return false;
    }
    for(Int i = 0; i < items.length; i++) {
      if(!items[i].match(scope, l.items[i])) {
        return false;
      }
    }
    return checkMatch(scope, condition, other);
  }

  as<String> {
    return items.as<String>;
  }
}

class diesler::ASTObjectMatch extends diesler::ASTMatch {
  String classString = null;
  Array<ASTPropertyMatch> properties = null;

  new(Scope scope, String classString, Array<ASTPropertyMatch> properties) extends super(scope["ASTObjectMatch"]) {
    this.classString = classString;
    this.properties = properties;
  }

  Bool match(Scope scope, DSLObject other) {
    DSLObject tmp = scope[classString];
    DSLClass klass = tmp.as<DSLClass>;
    if(!other.isInstanceOf(klass)) {
      return false;
    }
    for(ASTPropertyMatch pmt : properties) {
      if(other.getMethod(pmt.property) == null) {
        return false;
      }
      var result = other.getMethod(pmt.property).invoke(scope, other, new Array<DSLObject>());
      if(!pmt.pattern.match(scope, result)) {
        return false;
      }
    }
    return checkMatch(scope, condition, other);
  }

  as<String> {
    return properties.as<String>;
  }
}

class diesler::ASTPropertyMatch extends diesler::ASTMatch {
  String property = null;
  ASTMatch pattern = null;

  new(Scope scope, String property, ASTMatch pattern) extends super(scope["ASTPropertyMatch"]) {
    this.property = property;
    this.pattern = pattern;
  }
}

class diesler::ASTLiteralMatch extends diesler::ASTMatch {
  ASTNode value = null;

  new(Scope scope, ASTNode value) extends super(scope["ASTLiteralMatch"]) {
    this.value = value;
  }

  Bool match(Scope scope, DSLObject other) {
    var literalValue = scope.evalExp(value);
    if(literalValue == other) {
      return checkMatch(scope, condition, other);
    } else {
      return false;
    }
  }

  as<String> {
    return value.as<String>;
  }
}
