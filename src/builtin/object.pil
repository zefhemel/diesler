import "object.pil"
import "io.pil"
import "parser.pil"
import "ast/ast.pil"

import diesler
import diesler::exception

DSLClass diesler::builtin::object::init(Scope scope) {
  var object = new DSLClass(scope, null, "Object");

  object.setMethod("new", new diesler::builtin::object::NewInstanceMethod(scope));
  object.setMethod("defineInstance:", new diesler::builtin::object::DefineMethods(scope, true));
  object.setMethod("define:",  new diesler::builtin::object::DefineMethods(scope, false));
  object.setMethod("subClass:with:",  new diesler::builtin::object::SubclassMethod(scope));
  object.setMethod("importNativeClass:",  new diesler::builtin::native::NewNativeClassMethod(scope));
  object.setMethod("methods",  new diesler::builtin::object::MethodsMethod(scope));
  object.setMethod("instanceMethods",  new diesler::builtin::object::InstanceMethodsMethod(scope));
  object.setMethod("allMethods",  new diesler::builtin::object::AllMethodsMethod(scope));
  object.setMethod("allInstanceMethods",  new diesler::builtin::object::AllInstanceMethodsMethod(scope));

  object.setInstanceMethod("isA:", new diesler::builtin::object::IsAMethod(scope));
  object.setInstanceMethod("import:", new diesler::builtin::object::ImportMethod(scope));

  object.setInstanceMethod("==", new diesler::builtin::object::EqMethod(scope));
  object.setInstanceMethod("!=", new diesler::builtin::object::NotEqMethod(scope));

  object.setInstanceMethod("set:to:", new diesler::builtin::object::SetFieldMethod(scope));
  object.setInstanceMethod("get:", new diesler::builtin::object::GetFieldMethod(scope));
  object.setInstanceMethod("asString", new diesler::builtin::object::AsStringMethod(scope));
  object.setInstanceMethod("define:", new diesler::builtin::object::DefineMethods(scope, false));
  object.setInstanceMethod("methods", new diesler::builtin::object::MethodsMethod(scope));
  object.setInstanceMethod("allMethods", new diesler::builtin::object::AllMethodsMethod(scope));
  object.setInstanceMethod("getMethod:", new diesler::builtin::object::GetMethodMethod(scope));

  object.setInstanceMethod("print:", new diesler::builtin::object::PrintMethod(scope));
  object.setInstanceMethod("if:then:", new diesler::builtin::object::IfThenMethod(scope));
  object.setInstanceMethod("if:then:else:", new diesler::builtin::object::IfThenElseMethod(scope));
  object.setInstanceMethod("while:do:", new diesler::builtin::object::WhileMethod(scope));

  object.setInstanceMethod("try:catch:", new diesler::builtin::object::TryCatchMethod(scope));
  object.setInstanceMethod("raise:", new diesler::builtin::object::RaiseExceptionMethod(scope));
  return object;
}

class diesler::builtin::object::NewInstanceMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "new", new List<ASTPattern>(), null) {
    this.cls = cls;
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    var obj = new DSLObject(o.as<DSLClass>);
    if(obj.getMethod("init") != null) {
      obj.getMethod("init").invoke(scope, obj, new Array<DSLMethod>());
    }
    return obj;
  }
}

class diesler::builtin::object::SetFieldMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "set:to:", new List<ASTPattern>(new ASTIdnPattern(scope, "fieldName"), new ASTIdnPattern(scope, "value")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    var fieldName = args[0].as<DSLString>.value;
    o.setField(fieldName, args[1]);
    return o;
  }
}

class diesler::builtin::object::GetFieldMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "get:", new List<ASTPattern>(new ASTIdnPattern(scope, "fieldName")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    var fieldName = args[0].as<DSLString>.value;
    return o.getField(fieldName);
  }
}

class diesler::builtin::object::AsStringMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "asString", new List<ASTPattern>(), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    return new DSLString(scope, o.as<String>);
  }
}

class diesler::builtin::object::InstanceMethodsMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "instanceMethods", new List<ASTPattern>(), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    var l = new List<DSLObject>();
    var c = o.as<DSLClass>;
    if(c.instanceMethods != null) {
      for(String methodName : c.instanceMethods.keys) {
        l.add(c.instanceMethods[methodName]);
      }
    }
    return new DSLList(scope, l);
  }
}

class diesler::builtin::object::MethodsMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "methods", new List<ASTPattern>(), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    var l = new List<DSLObject>();
    if(o.methods != null) {
      for(String methodName : o.methods.keys) {
        l.add(o.methods[methodName]);
      }
    }
    if(!(o isa DSLClass) && o.cls != null) {
      DSLList classMethods = o.cls.getMethod("instanceMethods").invoke(scope, o.cls, args).as<DSLList>;
      for(DSLMethod m : classMethods.items) {
        l.add(m);
      }
    }
    return new DSLList(scope, l);
  }
}
class diesler::builtin::object::AllInstanceMethodsMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "instanceMethods", new List<ASTPattern>(), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    var l = new List<DSLObject>();
    var c = o.as<DSLClass>;
    if(c.instanceMethods != null) {
      for(String methodName : c.instanceMethods.keys) {
        l.add(c.instanceMethods[methodName]);
      }
    }
    if(c.superClass != null) {
      DSLList superMethods = c.superClass.getMethod("allInstanceMethods").invoke(scope, c.superClass, args).as<DSLList>;
      for(DSLMethod m : superMethods.items) {
        l.add(m);
      }
    }
    return new DSLList(scope, l);
  }
}

class diesler::builtin::object::AllMethodsMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "methods", new List<ASTPattern>(), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    var l = new List<DSLObject>();
    if(o.methods != null) {
      for(String methodName : o.methods.keys) {
        l.add(o.methods[methodName]);
      }
    }
    if(o.cls != null) {
      DSLList classMethods = o.cls.getMethod("allInstanceMethods").invoke(scope, o.cls, args).as<DSLList>;
      for(DSLMethod m : classMethods.items) {
        l.add(m);
      }
    }
    return new DSLList(scope, l);
  }
}

class diesler::builtin::object::GetMethodMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "getMethod:", new List<ASTPattern>(new ASTIdnPattern(scope, "selector")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    return o.getMethod(args[0].as<DSLString>.value);
  }
}

class diesler::builtin::object::PrintMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "print:", new List<ASTPattern>(new ASTIdnPattern(scope, "str")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    println(args[0].as<String>);
    return o;
  }
}

class diesler::builtin::object::DefineMethods extends DSLMethod {
  Bool instanceMethods = true;

  new(Scope scope, Bool instanceMethods) extends super(scope, "define:", new List<ASTPattern>(new ASTIdnPattern(scope, "methods")), null) {
    this.instanceMethods = instanceMethods;
  }

  DSLObject invoke(Scope scope, DSLObject self, Array<DSLObject> args) {
    DSLMethodDefs defs = args[0].as<DSLMethodDefs>;
    for(ASTMethodDef mdt : defs.declaredMethods) {
      var newMethod = new DSLMethod(scope, mdt.signature.selector, mdt.signature.arguments, new ASTBlock(scope, mdt.signature.arguments, mdt.statements));
      if(self isa DSLClass && instanceMethods) {
        self.as<DSLClass>.setInstanceMethod(mdt.signature.selector, newMethod);
      } else {
        self.setMethod(mdt.signature.selector, newMethod);
      }
    }
    return self;
  }
}

class diesler::builtin::object::SubclassMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "subClass:with:", new List<ASTPattern>(new ASTIdnPattern(scope, "className"), new ASTIdnPattern(scope, "methods")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject self, Array<DSLObject> args) {
    var className = args[0].as<DSLString>.value;
    var definitions = args[1].as<DSLMethodDefs>; 
    var cls = new DSLClass(scope, self.as<DSLClass>, className);
    for(ASTMethodDef mdt : definitions.declaredMethods) {
      var newMethod = new DSLMethod(scope, mdt.signature.selector, mdt.signature.arguments, new ASTBlock(scope, mdt.signature.arguments, mdt.statements));
      cls.setInstanceMethod(mdt.signature.selector, newMethod);
    }
    return cls;
  }
}

class diesler::builtin::object::IsAMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "isA:", new List<ASTPattern>(new ASTIdnPattern(scope, "class")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject self, Array<DSLObject> args) {
    return new DSLBool(scope, self.isInstanceOf(args[0].as<DSLClass>));
  }
}

class diesler::builtin::object::EqMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "==", new List<ASTPattern>(new ASTIdnPattern(scope, "other")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    return new DSLBool(scope, o == args[0]);
  }
}

class diesler::builtin::object::NotEqMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "!=", new List<ASTPattern>(new ASTIdnPattern(scope, "other")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    return new DSLBool(scope, !(o == args[0]));
  }
}

class diesler::builtin::object::IfThenMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "if:then:", new List<ASTPattern>(new ASTIdnPattern(scope, "condition"), new ASTIdnPattern(scope, "ifTrue")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    verifyType(args[0], typeof DSLMethod);
    verifyType(args[1], typeof DSLMethod);
    DSLMethod cond = args[0].as<DSLMethod>;
    DSLMethod trueBlock = args[1].as<DSLMethod>;
    DSLObject value = cond.invoke(scope, o, new Array<DSLObject>());
    if(!(value isa DSLBool)) {
      throw new Exception("Condition should return a Bool: " + cond.as<String>);
    }
    if(value.as<DSLBool>.value) {
      return trueBlock.invoke(scope, o, new Array<DSLObject>());
    }
    return o;
  }
}

class diesler::builtin::object::IfThenElseMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "if:then:else:", new List<ASTPattern>(new ASTIdnPattern(scope, "condition"), new ASTIdnPattern(scope, "ifTrue"), new ASTIdnPattern(scope, "ifFalse")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    verifyType(args[0], typeof DSLMethod);
    verifyType(args[1], typeof DSLMethod);
    verifyType(args[2], typeof DSLMethod);
    DSLMethod cond = args[0].as<DSLMethod>;
    DSLMethod trueBlock = args[1].as<DSLMethod>;
    DSLMethod falseBlock = args[2].as<DSLMethod>;
    DSLObject value = cond.invoke(scope, o, new Array<DSLObject>());
    if(!(value isa DSLBool)) {
      throw new Exception("Condition should return in bool: " + cond.as<String>);
    }
    if(value.as<DSLBool>.value) {
      return trueBlock.invoke(scope, o, new Array<DSLObject>());
    } else {
      return falseBlock.invoke(scope, o, new Array<DSLObject>());
    }
  }
}

class diesler::builtin::object::WhileMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "while:do:", new List<ASTPattern>(new ASTIdnPattern(scope, "condition"), new ASTIdnPattern(scope, "block")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    verifyType(args[0], typeof DSLMethod);
    verifyType(args[1], typeof DSLMethod);
    DSLMethod cond = args[0].as<DSLMethod>;
    DSLMethod block = args[1].as<DSLMethod>;
    DSLObject value = cond.invoke(scope, o, new Array<DSLObject>());
    if(!(value isa DSLBool)) {
      throw new Exception("Condition should return in bool: " + cond.as<String>);
    }
    while(value.as<DSLBool>.value) {
      block.invoke(scope, o, new Array<DSLObject>());
      if(scope.hasReturned) {
        return scope.returnValue;
      }
      value = cond.invoke(scope, o, new Array<DSLObject>());
    }
    return o;
  }
}

class diesler::builtin::object::TryCatchMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "try:catch:", new List<ASTPattern>(new ASTIdnPattern(scope, "tryBlock"), new ASTIdnPattern(scope, "catchBlock")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    DSLMethod tryBlock = args[0].as<DSLMethod>;
    DSLMethod catchBlock = args[1].as<DSLMethod>;
    Scope tryScope = new Scope(scope, o);
    try {
      tryBlock.invoke(tryScope, o, args);
    } catch(DieslerException e) {
      Scope catchScope = new Scope(scope, o);
      catchBlock.invoke(catchScope, o, new Array<DSLObject>(e.obj));
    }
    return new DSLNull(scope);
  }
}

class diesler::builtin::object::RaiseExceptionMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "raise:", new List<ASTPattern>(new ASTIdnPattern(scope, "exception")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    throw new DieslerException(args[0]);
  }
}

class diesler::builtin::object::ImportMethod extends DSLMethod {
  new(Scope scope) extends super(scope, "import:", new List<ASTPattern>(new ASTIdnPattern(scope, "filename")), null) {
  }

  DSLObject invoke(Scope scope, DSLObject o, Array<DSLObject> args) {
    var file = new pil::io::ReadFile(args[0].as<DSLString>.value);
    var content = file.readAll();
    file.close();
    ASTBlock block = new Parser(scope, content).acceptStatements();
    return block.eval(scope);
  }
}
