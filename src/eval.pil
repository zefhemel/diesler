// Important: do not import directly!

import "object.pil"
import "builtin/object.pil"
import "builtin/string.pil"
import "builtin/int.pil"
import "builtin/list.pil"
import "builtin/bool.pil"
import "builtin/native.pil"

import diesler::exception

@extend
class diesler::ASTNode extends DSLObject {
}

@extend
class diesler::ASTMessageSend extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    var o = object.eval(scope);
    var args = new Array<DSLObject>(arguments.length);
    for(Int i = 0; i < arguments.length; i++) {
      args[i] = arguments[i].evalExp(scope);
    }
    if(selector == "return:") {
      scope.returnValue = args[0];
      return scope.returnValue;
    }
    DSLMethod method = o.getMethod(selector);
    if(method == null) {
      throw new NoSuchMethodException(selector);
    }
    return method.invoke(scope, o, args);
  }
}

@extend
class diesler::ASTBlock extends diesler::ASTNode {

  DSLObject evalExp(Scope scope) {
    var m = new DSLMethod(scope, "noname", arguments, this);
    m.closure = scope;
    return m;
  }

  DSLObject eval(Scope scope) {
    DSLObject lastValue = null;
    for(ASTNode t : statements) {
      lastValue = t.eval(scope);
    }
    return lastValue;
  }
}

@extend
class diesler::ASTDeclBlock extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    return new DSLMethodDefs(scope, declaredMethods);
  }
}

@extend
class diesler::ASTPatternBlock extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    return new DSLPatternMethod(scope, patternCases);
  }
}

@extend
class diesler::ASTAssign extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    if(!lhs.match(scope, value.evalExp(scope), false)) {
      throw new Exception("Match failed!");
    }
    return null;
  }
}

@extend
class diesler::ASTLocalAssign extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    if(value == null) { // Just local variable declaration
      if(lhs isa ASTIdnPattern) {
        scope.setLocal(lhs.as<ASTIdnPattern>.idn, null);
        return null;
      } else if(lhs isa ASTListPattern) {
        for(ASTPattern m : lhs.as<ASTListPattern>.items) {
          if(m isa ASTIdnPattern) {
            scope.setLocal(m.as<ASTIdnPattern>.idn, null);
          } else {
            throw new DieslerException(new DSLString(scope, "Invalid variable declaration."));
          }
        }
        return null;
      } else {
        throw new DieslerException(new DSLString(scope, "Invalid variable declaration."));
      }
    }
    if(!lhs.match(scope, value.evalExp(scope), true)) {
      throw new Exception("Match failed!");
    }
    return null;
  }
}

@extend
class diesler::ASTList extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    var l = new List<DSLObject>();
    for(ASTNode t : values) {
      l.add(t.eval(scope));
    }
    return new DSLList(scope, l);
  }
}

@extend
class diesler::ASTInt extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    return new DSLInt(scope, value);
  }
}

@extend
class diesler::ASTBool extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    return new DSLBool(scope, value);
  }
}

@extend
class diesler::ASTString extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    return new DSLString(scope, value);
  }
}

@extend
class diesler::ASTIdn extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    var value = scope.get(idn);
    if(value == null) {
      throw new DieslerException(new DSLString(scope, "Unknown: " + idn));
    } else {
      return value;
    }
  }
}

@extend
class diesler::ASTFieldName extends diesler::ASTNode {
  DSLObject eval(Scope scope) {
    return scope.self.getField(fieldName);
  }
}
